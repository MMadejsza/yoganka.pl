import db from '../utils/db.js';
import * as models from '../models/_index.js';

export const postBookSchedule = (req, res, next) => {
	// @ Fetching USER
	// check if there is logged in User
	if (!req.user) {
		throw new Error('Użytkownik nie jest zalogowany');
		return res.status(401).json({message: 'Użytkownik nie jest zalogowany'});
	}
	let currentCustomer;
	// If it's not a Customer yet
	let customerPromise;
	if (!req.user.Customer) {
		console.log('Użytkownik nie jest klientem, tworzymy rekord Customer...');
		customerPromise = models.Customer.create({
			UserID: req.user.UserID,
			CustomerType: 'Indywidualny',
			FirstName: 'Imię',
			LastName: 'Nazwisko',
			DoB: new Date().toISOString().split('T')[0], // todays dummy date
		});
	} else {
		customerPromise = Promise.resolve(req.user.Customer);
	}

	//@ BOOKING
	db.transaction((t) => {
		return customerPromise
			.then((customer) => {
				currentCustomer = customer;
				// Fetch schedule and lock it for other paralele transactions
				return models.ScheduleRecord.findOne({
					where: {ScheduleID: req.body.schedule}, //from mutation
					transaction: t,
					lock: t.LOCK.UPDATE, //@
				});
			})
			.then((scheduleRecord) => {
				if (!scheduleRecord) {
					console.log('❗❗❗if (!scheduleRecord) {');
					throw new Error('Nie znaleziono terminu');
				}
				const scheduleDateTime = new Date(
					`${scheduleRecord.Date}T${scheduleRecord.StartTime}:00`,
				);
				if (scheduleDateTime < new Date()) {
					throw new Error('Nie można rezerwować terminu, który już minął.');
				}
				// console.log('scheduleRecord', scheduleRecord);
				// Count the current amount of reservations
				return models.BookedSchedule.count({
					where: {ScheduleID: req.body.schedule},
					transaction: t,
					lock: t.LOCK.UPDATE, //@
				}).then((currentBookings) => {
					// console.log('currentBookings', currentBookings);

					if (currentBookings >= scheduleRecord.Capacity) {
						// If limit is reached
						console.log('❗❗❗if (currentBookings >= scheduleRecord.capacity)');
						throw new Error('Brak wolnych miejsc na ten termin.');
						return res.status(409).json({
							message: 'Brak wolnych miejsc.',
						});
					}
					// IF still enough spaces - pass further
					return scheduleRecord;
				});
			})
			.then((scheduleRecord) => {
				// create booking
				return models.Booking.create(
					{
						CustomerID: currentCustomer.CustomerID,
						ScheduleID: req.body.schedule,
						Date: req.body.date,
						Product: req.body.product,
						Status: req.body.status,
						AmountPaid: req.body.amountPaid,
						AmountDue: req.body.amountDue,
						PaymentMethod: req.body.paymentMethod,
						PaymentStatus: req.body.paymentStatus,
					},
					{transaction: t},
				);
			})
			.then((booking) => {
				// After creating the reservation, we connected addScheduleRecord which was generated by Sequelize for many-to-many relationship between reservation and ScheduleRecord. The method adds entry to intermediate table (booked_schedules) and connects created reservation with schedule feeder (ScheduleRecord).
				// console.log('scheduleId:', req.body.schedule);
				return booking
					.addScheduleRecord(req.body.schedule, {
						through: {CustomerID: currentCustomer.CustomerID},
						transaction: t,
					})
					.then(() => booking); // We return instance for further .then blocks
			});
	})
		.then((booking) => {
			console.log('Rezerwacja utworzona pomyślnie');
			res.status(201).json({message: 'Rezerwacja utworzona pomyślnie', booking});
		})
		.catch((err) => {
			console.error(err);
			// If no enough spaces
			if (err.message === 'Brak wolnych miejsc na ten termin.') {
				console.log('❗❗❗if (err.message === Brak wolnych miejsc na ten termin');
				return res.status(409).json({message: err.message});
			}

			if (
				err.message === 'Użytkownik nie jest zalogowany.' ||
				err.message === 'Nie można rezerwować terminu, który już minął.'
			) {
				console.log('❗❗❗if (err.message === Brak wolnych miejsc na ten termin');
				return res.status(401).json({message: err.message});
			}
			// if the same customer tries to book the schedule
			if (
				err.name === 'SequelizeUniqueConstraintError' ||
				err.parent?.code === 'ER_DUP_ENTRY'
			) {
				console.log('❗❗❗if (SequelizeUniqueConstraintError');
				return res.status(409).json({
					message: 'Ten termin został już zarezerwowany przez tego klienta.',
				});
			}
			return res.status(500).json({message: err.message});
		});
};
export const postCancelSchedule = (req, res, next) => {
	const scheduleID = req.params.id;

	models.ScheduleRecord.findOne({where: {ScheduleID: scheduleID}})
		.then((scheduleRecord) => {
			if (!scheduleRecord) {
				throw new Error('Nie znaleziono terminu.');
			}
			const scheduleDateTime = new Date(
				`${scheduleRecord.Date}T${scheduleRecord.StartTime}:00`,
			);

			if (scheduleDateTime < new Date()) {
				throw new Error('Nie można zwolnić miejsca dla minionego terminu.');
			}
			return models.BookedSchedule.destroy({
				where: {
					ScheduleID: scheduleID,
					CustomerID: req.user.Customer.CustomerID,
				},
			}).then((deletedCount) => {
				if (deletedCount > 0) {
					return res
						.status(200)
						.json({message: 'Miejsce zwolnione - dziękujemy za informację :)'});
				} else {
					throw new Error('Nie znaleziono terminu.');
				}
			});
		})
		.catch((err) => {
			if (err.message === 'Nie znaleziono terminu.') {
				return res.status(404).json({message: err.message});
			}
			if (err.message == 'Nie można zwolnić miejsca dla minionego terminu.') {
				return res.status(409).json({message: err.message});
			}
			console.error(err);
			next(err);
		});
};

export const getEditCustomer = (req, res, next) => {
	console.log(`\n➡️➡️➡️ called getEditCustomer`);
	const customer = req.user.Customer;
	// console.log(customer);
	return res.status(200).json({customer});
};
export const postEditCustomer = (req, res, next) => {
	console.log(`\n➡️➡️➡️ called postEditSettings`);
	db.transaction()
		.then((t) => {
			const customerId = req.user.Customer.CustomerID;
			const newPhone = req.body.phone;
			const newContactMethod = req.body.cMethod;

			return models.CustomerPhones.update(
				{CustomerMobile: newPhone},
				{where: {CustomerID: customerId}, transaction: t},
			)
				.then((phoneResult) => {
					return models.Customer.update(
						{PreferredContactMethod: newContactMethod},
						{where: {CustomerID: customerId}, transaction: t},
					).then((customerResult) => {
						return {phoneResult, customerResult};
					});
				})
				.then((results) => {
					return t.commit().then(() => {
						console.log('Transaction committed, updates successful');
						const affectedPhoneRows = results.phoneResult[0];
						const affectedCustomerRows = results.customerResult[0];
						const status = affectedPhoneRows >= 1 || affectedCustomerRows >= 1;
						return res.status(200).json({
							confirmation: status,
							affectedPhoneRows,
							affectedCustomerRows,
						});
					});
				})
				.catch((err) => {
					return t.rollback().then(() => {
						console.log('Transaction rollback, error:', err);
						return res.status(500).json({error: err.message});
					});
				});
		})
		.catch((err) => {
			console.log('Error starting transaction:', err);
			return res.status(500).json({error: err.message});
		});
};

export const getShowBookingByID = (req, res, next) => {
	console.log(`\n➡️➡️➡️ customer called showBookingByID`);

	const PK = req.params.id;

	models.Booking.findByPk(PK, {
		through: {attributes: []}, // omit data from mid table
		required: false,
		attributes: {
			exclude: ['Product', 'CustomerID'],
		},
		include: [
			{
				model: models.Customer,
				attributes: {exclude: []},
			},
			{
				model: models.ScheduleRecord,
				attributes: {exclude: ['UserID']},
				through: {attributes: []}, // omit data from mid table
				include: [
					{
						model: models.Product,
						attributes: {exclude: []},
					},
				],
			},
		],
	})
		.then((booking) => {
			if (!booking) {
				return res.redirect('/admin-console/show-all-bookings');
			}
			console.log('\n✅✅✅ Booking fetched');
			return res.status(200).json({isLoggedIn: req.session.isLoggedIn, booking});
		})
		.catch((err) => console.log(err));
};
